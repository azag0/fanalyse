File: ProgramUnit*;
ProgramUnit:
    EOL?
    (Type | /recursive|elemental|pure/)* type=UnitType name=ID_ ('(' parameters*=ID_[','] ')')?
    ('result' '(' ID_ ')')? ('bind' '(' 'c' (',' 'name' '=' STRING )? ')')? EOL
    imports=UseStatement*
    ('implicit' ('none' | Type '(' /[a-z]-[a-z]/+[','] ')') EOL)?
    declarations=DeclarationStatement*
    body=ExecutableStatement*
    ('contains' EOL
    contains*=ProgramUnit)?
    'end' (UnitType ID_?)? EOL
;

Type: TypeName ('*' (INT | '(' (Expression | '*') ')') | '(' ('kind' '=' Expression | ('len' '=')? (Expression | '*' | ':'))+[','] ')')?;
TypeName: 'double' ('precision' | 'complex') | /integer|logical|character|real|complex/ | CustomTypeName | ProcedureTypeName;
CustomTypeName: ('type' | 'class') '(' name=ID_ ')';
ProcedureTypeName: 'procedure' '(' name=ID_ ')';
UnitType: /program|subroutine|module|function/;

UseStatement: 'use' (',' 'intrinsic' '::')? module=ID_ (',' ('only' ':')? names+=Rename[','])* EOL;
Rename: FunctionName ('=>' FunctionName)?;

DeclarationStatement:
    ScopeDeclaration | ModuleInterface | InterfaceBlock | CustomTypeDeclaration |
    ExternalDeclaration | SaveDeclaration | DimensionStatement |
    ParameterStatement | IncludeStatement | DataStatement | IntrinsicStatement |
    ImportStatement | CommonBlock |
    VariableDeclaration |
    StatementFunction
;
ScopeDeclaration: scope=Scope ('::'? names+=FunctionName[','])? EOL;
Scope: 'private' | 'public';
ModuleInterface:
    'interface' FunctionName EOL
    ('module' 'procedure' funcs+=ID_[','] EOL)+
    'end' 'interface' FunctionName? EOL
;
InterfaceBlock:
    'abstract'? 'interface' EOL
    headers+=FunctionHeader
    'end' 'interface' EOL
;
CustomTypeDeclaration:
    'type' ((',' Scope | ',' 'bind' '(' 'c' ')')* '::')? name=ID_ EOL
    attributes*=DeclarationStatement
    ('contains' EOL
    methods*=MethodDeclaration)?
    'end' 'type' ID_? EOL
;
ExternalDeclaration: 'external' '::'? names+=ID_[','] EOL;
SaveDeclaration: 'save' variables*=ID_[','] EOL;
DimensionStatement: 'dimension' variables+=VariableNameDefault[','] EOL;
ParameterStatement: 'parameter' '(' variables+=VariableNameDefault[','] ')' EOL;
IncludeStatement: 'include' STRING EOL;
DataStatement: 'data' DataSpecification+[','] EOL;
DataSpecification: LHS+[','] '/' Expression+[','] '/';
IntrinsicStatement: 'intrinsic' '::'? ID_+[','] EOL;
ImportStatement: 'import' '::'? ID_*[','] EOL;
CommonBlock: 'common' CommonSpecification+[','] EOL;
CommonSpecification: '/' ID_? '/' LHS+[','];
VariableDeclaration: type=Type (',' modifiers+=TypeModifier[','])? '::'? variables+=VariableNameDefault[','] EOL;
TypeModifier:
    'intent' '(' ('in' 'out' | 'in' | 'out') ')' |
    'dimension' '(' dimensions+=DimensionSpec[','] ')' |
    /parameter|allocatable|optional|target|pointer|save|value|public|private|external|protected/
;
VariableNameDefault: name=ID_ ('(' dimensions+=DimensionSpec[','] ')' | '*' INT)? ('=' value=Expression | '=>' 'null' '(' ')')?;
DimensionSpec: (from=Expression? ':' to=Expression?) | to=Expression | '*';
FunctionName: OperatorFunction | ID_;
OperatorFunction: 'operator' '(' operator=CustomOperator ')';
StatementFunction: LHS '=' Expression EOL;
FunctionHeader:
    (Type | /recursive|elemental|pure/)* type=UnitType name=ID_ ('(' parameters*=ID_[','] ')')?
    ('result' '(' ID_ ')')? ('bind' '(' 'c' (',' 'name' '=' STRING )? ')')? EOL
    imports=UseStatement*
    ('implicit' ('none' | Type '(' /[a-z]-[a-z]/+[','] ')') EOL)?
    declarations=DeclarationStatement*
    'end' (UnitType ID_?)? EOL
;
MethodDeclaration: 'procedure' ',' 'pass' '::' ID_ '=>' ID_ EOL;

ExecutableStatement:
    CallStatement | IfBlock | IfStatement | SelectBlock |
    DoBlock | DoStatement | ForallBlock | ForallStatement |
    WhereBlock | WhereStatement |
    AssociateStatement |
    AllocateStatement | DeallocateStatement |
    NullifyStatement |
    OpenStatement | WriteStatement | ReadStatement | CloseStatement | Backspace |
    Rewind | AssignStatement |
    InquireStatement | PrintStatement | FormatStatement |
    PointerAssignment | Assignment |
    ('stop' (STRING | INT)? | 'exit' ID_? | INT? 'continue' |
    'go' 'to' ('(' INT+[','] ')' ',')? Expression | 'cycle' ID_? | INT? 'return') EOL
;
CallStatement: INT? 'call' call=LHS EOL;
IfBlock :
    (ID_ ':' | INT)? 'if' branches=Branch
    ('else' 'if' branches=Branch)*
    ('else' branches=DefaultBranch)?
    'end' 'if' ID_? EOL
;
IfStatement: INT? 'if' '(' condition=Expression ')' body=ExecutableStatement;
SelectBlock:
    'select' 'case' '(' condition=Expression ')' EOL
    branches*=Case
    'end' 'select' EOL
;
DoBlock:
    (ID_ ':')? /do\s/ ('while' '(' condition=Expression ')' | INT? ID_ '=' from=Expression ',' to=Expression (',' by=Expression)?)? EOL
    // TODO: remove space in 'do ', check on cg_scalapack.f90
    body=ExecutableStatement*
    'end' 'do' ID_? EOL
;
DoStatement: 'do' INT ','? ID_ '=' from=Expression ',' to=Expression (',' by=Expression)? EOL;
ForallBlock: 'forall' '(' iters+=IterSpec[','] ')' EOL body*=ExecutableStatement 'end' 'forall' EOL;
ForallStatement: 'forall' '(' iters+=IterSpec[','] ')' body=ExecutableStatement;
WhereBlock:
    'where' '(' Expression ')' EOL
    body*=ExecutableStatement
    ('elsewhere' EOL
    elsebody*=ExecutableStatement)?
    'end' 'where' EOL
;
WhereStatement: 'where' '(' Expression ')' body=ExecutableStatement;
AssociateStatement:
    'associate' '(' aliases+=Alias[','] ')' EOL
    body*=ExecutableStatement
    'end' 'associate' EOL
;
Alias: name=ID_ '=>' Expression;
AllocateStatement: 'allocate' '(' (Type '::')? variables+=Parameter[','] ')' EOL;
DeallocateStatement: 'deallocate' '(' parameters+=Parameter[','] ')' EOL;
NullifyStatement: 'nullify' '(' names+=LHS[','] ')' EOL;
OpenStatement: 'open' '(' parameters*=Parameter[','] ')' EOL;
WriteStatement: 'write' '(' parameters*=Parameter[','] ')' ','? args*=ExpressionOrIterator[','] EOL;
PrintStatement: 'print' Parameter (',' args*=Expression[','])? EOL;
FormatStatement: INT 'format' '(' args+=FormatExpression[','] ')' EOL;
ReadStatement: 'read' '(' parameters*=Parameter[','] ')' vars*=ReadTarget[','] EOL;
CloseStatement: 'close' '(' parameters*=Parameter[','] ')' EOL;
Backspace: 'backspace' '(' Expression ')' EOL;
Rewind: 'rewind' Expression EOL;
AssignStatement: 'assign' INT 'to' ID_ EOL;
InquireStatement: 'inquire' '(' parameters*=Parameter[','] ')' ID_? EOL;
PointerAssignment: pointer=LHS '=>' target=LHS EOL;
Assignment: INT? target=LHS '=' value=Expression EOL;

Parameter: value=Expression | (name=ID_ '=')? value=ExpressionOrStar;
ExpressionOrStar: Expression | '*';
Branch: '(' condition=Expression ')' 'then' EOL body=ExecutableStatement*;
DefaultBranch: EOL body=ExecutableStatement*;
Case: 'case' ('(' case+=CaseValue[','] ')' | 'default') EOL body=ExecutableStatement*;
CaseValue: CaseSlice | Expression;
CaseSlice: Expression? ':' Expression?;
IterSpec: itervar=ID_ '=' slice=Slice;
ReadTarget: LHS | Iterator;
ExpressionOrIterator: Expression | Iterator;
FormatExpression: FormatTerm? '/' FormatTerm? | INT? FormatTerm;
FormatTerm: STRING_ | FormatSpecifier | '(' FormatTerm+[','] ')';
FormatSpecifier: /[.\w]+/;

Expression: operands=Term (operators=Operator operands=Term)* !'=';
Term:
    LHS | Array | (INT_ &CustomOperator) | FLOAT_ | INT_ |
    STRING_ | BOOL_ | UnaryTerm | Complex | Parenthesised
;
LHS: components=ArrayCall ('%' components=ArrayCall)*;
ArrayCall: variable=ID_ ('(' parameters*=Slice[','] ')')? ('(' slice=Slice ')')?;
Slice: from=Expression? ':' to=Expression? (':' by=Expression)? | to=Expression | (name=ID_ '=')? value=ExpressionOrStar;
Array: '(/' members*=ArrayMember[','] '/)' | '[' (Type '::')? members*=ArrayMember[','] ']';
ArrayMember: Iterator | Expression;
Iterator: '(' values+=ExpressionOrIterator[','] ',' var=ID_ '=' from=Expression ',' to=Expression (',' by=Expression)? ')';
UnaryTerm: operator=Unary operand=Term;
Unary: /\.not\.|-|\+/;
Parenthesised: '(' inner=Expression ')';
CustomOperator: /\.[a-z]+\./;
Operator: CustomOperator | /\/\/|>=|<=|\/=|==|>|<|\/|\+|\*\*|\*|-/;

ID_: /[^_\d\W]\w*\b/;
BOOL_: /\.true\.|\.false\./;
FLOAT_: /-?(\d*\.\d+|\d+\.\d*|\d+)([de][-+]?\d+)?(_[0-9a-z_]+)?/;
INT_: INT | /-?\d+(_[0-9a-z_]+)?/;
Complex: '(' FLOAT_ ',' FLOAT_ ')';
STRING_: MultiString | STRING;
MultiString: parts=STRING parts+=STRING;
// The MultiString is a hack that deals with two issues:
// 1. multline strings, which cannot be distinguished from linebreaks
// 2. escaping of a quote in fortran, which is incompatible with python

Comment: /!.*$|^#.*$|& *(!.*)?(\n[\t ]*(!.*)?$)*\n[\t ]*&?/;
EOL: (/[\n;]\s*/)*;
