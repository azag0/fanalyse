ProgramUnit:
    EOL?
    Type? 'elemental'? type=UnitType name=ID_ ('(' parameters*=ID_[','] ')')? ('result' '(' ID_ ')')? EOL
    imports=UseStatement*
    ('implicit' 'none' EOL)?
    declarations=DeclarationStatement*
    body=ExecutableStatement*
    ('contains' EOL
    contains*=ProgramUnit)?
    'end' UnitType ID_? EOL
;

Type: TypeName ('*' INT | '(' ('kind' '=' Expression | ('len' '=')? (Expression | '*'))+ ')')?;
TypeName: 'double' 'precision' | /integer|logical|character|real|complex/ | CustomTypeName;
CustomTypeName: 'type' '(' name=ID_ ')';
UnitType: /program|subroutine|module|function/;

UseStatement: 'use' module=ID_ (',' 'only' ':' names+=FunctionName[','])? EOL;

DeclarationStatement:
    ScopeDeclaration | InterfaceDeclaration | CustomTypeDeclaration |
    ExternalDeclaration |
    VariableDeclaration
;
ScopeDeclaration: scope='private' EOL | scope='public' '::' names+=FunctionName[','] EOL;
InterfaceDeclaration:
    'interface' FunctionName EOL
    ('module' 'procedure' funcs=ID_ EOL)+
    'end' 'interface' EOL
;
CustomTypeDeclaration:
    'type' '::' name=ID_ EOL
    attributes*=VariableDeclaration
    'end' 'type' ID_? EOL
;
ExternalDeclaration: 'external' '::' names+=ID_[','] EOL;
VariableDeclaration: type=Type (',' modifiers+=TypeModifier[','])? '::'? variables+=VariableNameDefault[','] EOL;
TypeModifier:
    'intent' '(' /inout|in|out/ ')' |
    'dimension' '(' dimensions+=DimensionSpec[','] ')' |
    /parameter|allocatable|optional|target|pointer|save/
;
VariableNameDefault: name=ID_ ('(' dimensions+=DimensionSpec[','] ')')? ('=' value=Expression)?;
DimensionSpec: (from=Expression? ':' to=Expression?) | to=Expression;
FunctionName: OperatorFunction | ID_;
OperatorFunction: 'operator' '(' operator=CustomOperator ')';

ExecutableStatement:
    CallStatement | IfBlock | IfStatement | SelectBlock |
    DoBlock | ForallBlock | ForallStatement |
    WhereBlock | WhereStatement |
    AssociateStatement |
    AllocateStatement | DeallocateStatement |
    NullifyStatement |
    OpenStatement | WriteStatement | ReadStatement | CloseStatement |
    InquireStatement | PrintStatement |
    PointerAssignment | Assignment |
    ('stop' INT? | 'exit' ID_? | INT? 'continue' | 'go' 'to' INT | /cycle|return/) EOL
;
CallStatement: 'call' subroutine=ID_ ('(' parameters*=Parameter[','] ')')? EOL;
IfBlock :
    'if' branches=Branch
    ('else' 'if' branches=Branch)*
    ('else' branches=Branch)?
    'end' 'if' EOL
;
IfStatement: 'if' '(' condition=Expression ')' body=ExecutableStatement;
SelectBlock:
    'select' 'case' '(' condition=Expression ')' EOL
    branches*=Case
    'end' 'select' EOL
;
DoBlock :
    (ID_ ':')? 'do' ('while' '(' condition=Expression ')' | ID_ '=' from=Expression ',' to=Expression (',' by=Expression)?)? EOL
    body=ExecutableStatement*
    'end' 'do' ID_? EOL
;
ForallBlock: 'forall' '(' iters+=IterSpec[','] ')' EOL body*=ExecutableStatement 'end' 'forall' EOL;
ForallStatement: 'forall' '(' iters+=IterSpec[','] ')' body=ExecutableStatement;
WhereBlock: 'where' '(' Expression ')' EOL body*=ExecutableStatement 'end' 'where' EOL;
WhereStatement: 'where' '(' Expression ')' body=ExecutableStatement;
AssociateStatement:
    'associate' '(' aliases+=Alias[','] ')' EOL
    body*=ExecutableStatement
    'end' 'associate' EOL
;
Alias: name=ID_ '=>' Expression;
AllocateStatement: 'allocate' '(' variables+=Parameter[','] ')' EOL;
DeallocateStatement: 'deallocate' '(' parameters+=Parameter[','] ')' EOL;
NullifyStatement: 'nullify' '(' names+=LHS[','] ')' EOL;
OpenStatement: 'open' '(' parameters*=Parameter[','] ')' EOL;
WriteStatement: 'write' '(' parameters*=Parameter[','] ')' args*=WriteSource[','] EOL;
PrintStatement: 'print' Parameter (',' args*=Expression[','])? EOL;
ReadStatement: 'read' '(' parameters*=Parameter[','] ')' vars+=ReadTarget[','] EOL;
CloseStatement: 'close' '(' parameters*=Parameter[','] ')' EOL;
InquireStatement: 'inquire' '(' parameters*=Parameter[','] ')' EOL;
PointerAssignment: pointer=LHS '=>' target=LHS EOL;
Assignment: target=LHS '=' value=Expression EOL;

Parameter: (name=ID_ '=')? value=Expression | value='*';
Branch: ('(' condition=Expression ')' 'then')? EOL body=ExecutableStatement*;
Case: 'case' ('(' case+=CaseValue[','] ')' | 'default') EOL body=ExecutableStatement*;
CaseValue: INT | STRING | LHS;
IterSpec: itervar=ID_ '=' slice=Slice;
ReadTarget: LHS | Iterator;
WriteSource: Expression | Iterator;

Expression: operands=Term (operators=Operator operands=Term)*;
Term:
    FunctionCall | LHS | Array | (INT &CustomOperator) | FLOAT_ | INT |
    STRING | BOOL_ | UnaryTerm | Complex | Parenthesised
;
FunctionCall: function=ID_ '(' parameters*=Parameter[','] ')' !'%';
LHS: components=ArrayCall ('%' components=ArrayCall)*;
ArrayCall: variable=ID_ ('(' parameters*=Slice[','] ')')?;
Slice: (from=Expression? ':' to=Expression? (':' by=Expression)?) | to=Expression;
Array: '(/' members*=ArrayMember[','] '/)' | '[' members*=ArrayMember[','] ']';
ArrayMember: Iterator | Expression;
Iterator: '(' value=Expression ',' var=ID_ '=' from=Expression ',' to=Expression (',' by=Expression)? ')';
UnaryTerm: operator=Unary operand=Term;
Unary: /\.not\.|-/;
Parenthesised: '(' inner=Expression ')';
CustomOperator: /\.[a-z]+\./;
Operator: CustomOperator | /\/\/|>=|<=|\/=|==|>|<|\/|\+|\*\*|\*|-/;

ID_: /[^_\d\W]\w*\b/;
BOOL_: /\.true\.|\.false\./;
FLOAT_: /-?(\d*\.\d+|\d+\.\d*|\d+)([de]-?\d+)?(_[a-z]+)?/;
Complex: '(' FLOAT_ ',' FLOAT_ ')';

Comment: /!.*$|& *(!.*)?(\n *!.*$)*\n *&?/;
EOL: (/[\n;]\s*/)*;
